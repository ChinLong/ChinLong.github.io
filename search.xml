<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot-对国际化的一些思考]]></title>
    <url>%2F2018%2F12%2F01%2FSpringBoot-%E5%AF%B9%E5%9B%BD%E9%99%85%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[前前言 之前所说的博客一个月更新一篇的，已经解决两个月没有更新了，真的是罪过罪过。。。 前言 SpringBoot在之前的项目中有使用过，也是需要国际化的。当时做法是设置个参数在url中，觉得不够优雅。 最近在研究国际化的问题，发现自己还是有必要重新学习下Spring呀，大神们都已经帮我们封装好了，而我们却不会用，真的是丢脸啊。。。 一些讲解 国际化主要接口是LocaleResolver,就两个方法。123456interface LocaleResolver &#123; /* 返回Request当前的地区 */ Locale resolveLocale(HttpServletRequest request); /* 设置地区 */ void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale);&#125; 自己只需要实现这个接口就可以了。幸好Spring还给了我们4个基本实现。AcceptHeaderLocaleResolver,CookieLocaleResolver,FixedLocaleResolver和SessionLocaleResolver. 参考其他前端框架，把地区设置到cookie中，是个比较好的选择，这样就可以和Session解耦，可以Stateless了。 直接开干：application.yml 定义配置。 1234567messages: basename: i18n/messages encoding: UTF-8 use-code-as-default-message: truemvc: static-path-pattern: /static/** date-format: yyyy-MM-dd 编写默认国际化语言文件123messages_en_US.properties default=defaultmessages_ja_JP.properties default=デフォルトmessages_zh_CN.properties default=默认 定义Constant类123public class I18nConstant &#123; public static final String DEFAULT = "default";&#125; 配置个MVC配置。WebMvcConfig 主要是定义 默认Cookie名，默认地区，支持地区语言，CookieLocaleResolver的Bean和添加一个I18nInterceptor拦截器。1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Bean public LocaleResolver localeResolver() &#123; CookieLocaleResolver localeResolver = new CookieLocaleResolver(); localeResolver.setDefaultLocale(Locale.CHINA); localeResolver.setCookieName(LocaleChangeInterceptor.DEFAULT_PARAM_NAME); localeResolver.setCookieMaxAge(60 * 60 * 24 * 365); // Cookie时效设为1年 return localeResolver; &#125; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry // 允许所有CORS访问 .addMapping("/**") .allowedMethods( HttpMethod.GET.name(), HttpMethod.POST.name(), HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.HEAD.name(), HttpMethod.OPTIONS.name() ); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 这里使用默认的Cookie国际化拦截器 registry.addInterceptor(new LocaleChangeInterceptor()) .addPathPatterns("/**") .excludePathPatterns("/webjars/**", "/static/**"); // 拦截器见下面定义 registry.addInterceptor(new I18nInterceptor()) .addPathPatterns("/**") .excludePathPatterns("/webjars/**", "/static/**"); &#125;&#125; 编写I18nInterceptor拦截器主要做了一件事，postHandle 将I18nConstant中定义的静态常量注册到ModelAndView里，给前端使用。123456789101112131415161718192021222324252627@Componentpublic class I18nInterceptor extends HandlerInterceptorAdapter &#123; private static Map&lt;String, Object&gt; i18nMaps = new HashMap&lt;&gt;(); static &#123; try &#123; // 将I18nConstant定义的静态常量放入 Field[] fields = I18nConstant.class.getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); if (field.getType().equals(String.class) &amp;&amp; Modifier.isStatic(field.getModifiers())) &#123; i18nMaps.put(field.getName(), field.get(I18nConstant.class)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) &#123; if (null != modelAndView) &#123; modelAndView.addObject("i18n", i18nMaps); &#125; &#125;&#125; 使用多语言。这次前端使用的是Freemarker。12345&lt;#--将下列放入Head处 --&gt;&lt;#import &quot;spring.ftl&quot; as spring&gt;&lt;#-- 下面两种方法都是可以的 --&gt;&lt;@spring.message code=&quot;$&#123;i18n.DEFAULT&#125;&quot;/&gt;&lt;@spring.message code=&quot;default&quot;/&gt; 编写API使用类1234567891011121314151617181920212223242526272829303132@Componentpublic class I18nMessage &#123; private final HttpServletRequest request; private final MessageSource messageSource; @Autowired public I18nMessage(MessageSource messageSource, HttpServletRequest request) &#123; this.messageSource = messageSource; this.request = request; &#125; public String getMessage(String code) &#123; return getArgsMessage(code, null); &#125; public String getMessage(String code, String defaultMessage) &#123; return getArgsMessage(code, null, defaultMessage); &#125; public String getArgsMessage(String code, Object[] args) &#123; Locale locale = RequestContextUtils.getLocale(request); return messageSource.getMessage(code, args, locale); &#125; public String getArgsMessage(String code, Object[] args, String defaultMessage) &#123; Locale locale = RequestContextUtils.getLocale(request); return messageSource.getMessage(code, args, defaultMessage, locale); &#125;&#125; Controller使用12345678910111213141516@RestController@RequestMapping("/api/v1")public class ApiCtl &#123; private final I18nMessage i18nMessage; @Autowired public ApiCtl(I18nMessage i18nMessage) &#123; this.i18nMessage = i18nMessage; &#125; @GetMapping("/i18n") public String getI18n() &#123; return i18nMessage.getMessage(I18nConstant.DEFAULT); &#125;&#125; 结尾这样就可以将国际化的多语言设置好了 注意：request.getLocale() 获取的语言并不是自己设置的语言。 获取的话需要使用RequestContextUtils.getLocale(request)。]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>I18n</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Directory-对Scala代码的移植]]></title>
    <url>%2F2018%2F09%2F01%2FDirectory-%E5%AF%B9Scala%E4%BB%A3%E7%A0%81%E7%9A%84%E7%A7%BB%E6%A4%8D%2F</url>
    <content type="text"><![CDATA[背景 在一个小项目中，想用Scala的Directory的类中一个方法，但项目中并不能加入Scala的依赖。所以就决定吧Scala代码移植为Java的代码。 分析 Scala中Directory继承Path，并重写了toAbsolute,toDirectory,toFile和normalize方法，新增了list,dirs,files,deepFiles,deepList方法。 其实Path类重写了java.io.File方法，所以我们只需要重写一个Directory即可。 代码展示 Gitee代码链接：点击这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class Directory &#123; private final File file; public Directory(File file) &#123; this.file = file; &#125; public Directory(String filePath) &#123; this.file = new File(filePath); &#125; public File getFile() &#123; return this.file; &#125; public List&lt;Directory&gt; dirs() &#123; if (this.file.isDirectory()) &#123; File[] files = file.listFiles(File::isDirectory); if (files == null) &#123; return new ArrayList&lt;&gt;(); &#125; return Stream.of(files).map(Directory::new).collect(Collectors.toList()); &#125; else &#123; return new ArrayList&lt;&gt;(); &#125; &#125; public List&lt;File&gt; list() &#123; File[] files = file.listFiles(); if (files == null) &#123; return new ArrayList&lt;&gt;(); &#125; return new ArrayList&lt;&gt;(Arrays.asList(files)); &#125; public List&lt;File&gt; deepFiles() &#123; return deepList().stream().filter(File::isFile).collect(Collectors.toList()); &#125; public List&lt;File&gt; deepList() &#123; return deepList(-1); &#125; public List&lt;File&gt; deepList(int depth) &#123; if (depth &lt; 0) &#123; List&lt;File&gt; files1 = list(); List&lt;File&gt; files2 = dirs().stream().flatMap(v -&gt; v.deepList(-1).stream()) .collect(Collectors.toList()); files1.addAll(files2); return files1; &#125; else if (depth == 0) &#123; return new ArrayList&lt;&gt;(); &#125; else &#123; List&lt;File&gt; files1 = list(); List&lt;File&gt; files2 = dirs().stream().map(v -&gt; v.deepList(depth - 1)) .flatMap(Collection::stream).collect(Collectors.toList()); files1.addAll(files2); return files1; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery-Ajax的简单封装]]></title>
    <url>%2F2018%2F08%2F01%2FjQuery-Ajax%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[jQuery-Ajax简单封装最近在写一个小工具，因为小所以就只用了jQuery和Bootstrap。jQuery的ajax方法虽然很具体，但每次写这些就有点嫌多。对Ajax一些常用方法稍微封装了一下。 源码如下:123456789101112131415161718192021222324252627282930313233343536373839/** * Ajax异步请求 * async: true * * @param &#123;string&#125; url 请求URL * @param &#123;string&#125; type GET,POST,PUT,DELETE,HEAD,OPTION方法 * @param &#123;object&#125; callback 回调函数(optional) * @param &#123;object/string&#125; data 请求数据(optional) * @param &#123;object&#125; opt_settings 其他设定(optional) */ $.doAjax = function(url, type, callback, data, opt_settings) &#123; let obj = &#123; url : url, type : type, async : true &#125;; if (typeof callback === "object")&#123; if (typeof callback.success !== "undefined")&#123; obj.success = callback.success &#125; if (typeof callback.complete !== "undefined")&#123; obj.complete = callback.complete &#125; if (typeof callback.error !== "undefined")&#123; obj.error = callback.error &#125; &#125; if(typeof data !== "undefined")&#123; obj.data = typeof data === "object" ? JSON.stringify(data) : data; //obj.dataType = "json"; obj.contentType = "application/json"; &#125; $.ajax($.extend(obj, opt_settings)); &#125;; 调用：123456789101112131415161718192021222324252627282930let url1 = "/users";let url2 = "/users/1";let callback = &#123; success: function(json,xhr,option)&#123; console.log(json); &#125;, error: function(json,xhr,option)&#123; console.error(json); &#125;&#125;;// GET 查询所有用户$.doAjax(url1,"GET",callback1);let user = &#123; username: "xiaoming", sex: "male", age: "28"&#125;;// POST 新增用户$.doAjax(url2, "POST", callback, user);// PUT 新增用户$.doAjax(url2, "PUT", callback, user);// DELETE 删除用户$.doAjax(url2, "DELETE", callback); 这样就是一个简单的封装，使用起来还算比较方便。]]></content>
      <tags>
        <tag>jQuery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chinlong's Blog]]></title>
    <url>%2F2018%2F07%2F01%2FChinlong's-Blog%2F</url>
    <content type="text"><![CDATA[初次搭建，多多关照。每月坚持写一篇，请监督！]]></content>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
</search>
